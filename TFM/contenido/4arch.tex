\chapter{Arquitectura del sistema propuesto}
\label{chap:sysarch}
\lettrine{E}{n} este capítulo se comenta la arquitectura  del sistema propuesto y de los nuevos componentes: procesamiento de vídeo, reconocimiento adaptativo y personas registradas.

\section{Arquitectura general}
\label{sec:partarch}

Para entender mejor la arquitectura general, se empezará por explicar la arquitectura base de la que se parte y del nodo cámara, el componente más importante. A continuación, se explicarán las mejoras de la arquitectura final extendida.

\subsection{Arquitectura base}
\label{sec:basearch}

\begin{figure}[tbp]
    \centering
    \includegraphics[width=0.45\linewidth]{imagenes/SYSARCH.jpg}
    \caption[Arquitectura del sistema base de partida]{Arquitectura del sistema base de partida, figura extraída de \cite{andrew}}
    \label{fig:sysarch}
\end{figure}

Como ya se ha comentado en la introducción, en este proyecto se parte de un sistema diseñado para el robot móvil Summit\_XL, compuesto por dos cámaras \acrshort{rgbd} y un sensor \acrshort{lidar}, que \textbf{detecta y reconoce personas} a partir de nodos que aplican los respectivos \textbf{modelos de redes neuronales convolucionales} (o \acrshort{cnn}).

En la figura \ref{fig:sysarch} se muestra la arquitectura planteada en \cite{andrew}, compuesta por un nodo que recibe \glspl{pcl} \acrshort{3d} del entorno y otorga las posiciones \acrshort{3d} de las personas detectadas mediante el respectivo modelo (nodo \acrshort{lidar}) y 1 o varios nodos que detectan y reconocen personas mediante los datos \acrshort{rgb} y obtienen su posición \acrshort{3d} mediante la imagen de distancias de las cámaras. La información generada por los nodos \textbf{se fusiona} y se devuelve en forma de una \textbf{lista final de todos los individuos reconocidos y su posición \acrshort{3d}} (nodo integración de sensores). El sistema opera \textbf{frame a frame}, es decir, devuelve la información de los individuos en cada frame capturado por las cámaras.

Toda la arquitectura se ejecuta en el \textbf{\textit{framework} \acrshort{ros}} \cite{ROS} (sección \ref{sec:ros}). \acrshort{ros} se encarga de crear los procesos para cada nodo, comprobar su estado, regular la frecuencia a la que trabajan, crear la red en la que dichos procesos intercambian mensajes, entre otros muchos detalles que resultan transparentes para el programador.

\subsection{Nodo cámara}

\begin{figure}[tbp]
    \centering
    \includegraphics[width=0.8\linewidth]{imagenes/CAMNOD.jpg}
    \caption[Arquitectura del nodo cámara]{Arquitectura del nodo cámara, figura extraída de \cite{andrew}}
    \label{fig:camnod}
\end{figure}

En la figura \ref{fig:camnod} se muestra el flujo del nodo cámara. Dicho nodo sigue un enfoque \textbf{multimodal}, es decir, utiliza las \textbf{características} tanto \textbf{faciales} como \textbf{corporales} del individuo para su detección y reconocimiento.

Tras recibir el frame \acrshort{rgb}, este es procesado por \textbf{dos modelos de detección}, uno destinado a rostros (YuNet en la figura \ref{fig:camnod}) y el otro a cuerpos (YOLO en la figura \ref{fig:camnod}), de los que se obtienen las \glspl{bbox} (o recortes) de los rostros y cuerpos detectados, que se comparan para asegurar que cada recorte facial se encuentra contenido en cada recorte corporal. Posteriormente, se procede al \textbf{reconocimiento facial} (ArcFace) y corporal (OSNet), que devuelven los respectivos \glspl{embedding} de los que se computa la \textbf{distancia coseno} (otorga el grado de similitud entre dos vectores considerando el ángulo entre ellos) con todos los \glspl{embedding} (sujetos) guardados en la base de datos, de forma que se obtiene una lista ordenada de los sujetos \textbf{según el grado de similitud}.

La identidad del individuo puede determinarse como la \textbf{primera entrada} de la lista (es decir, la identidad \textit{a priori} más parecida) o puede procesarse y obtener la identidad por medio de algoritmos más avanzados (en \cite{andrew} se proponen los métodos de distancia relativa e identidad probable).

Finalmente, el nodo cámara devuelve la identidad facial y corporal de los individuos, junto a su posición \acrshort{3d}, calculada a partir de la imagen de distancias y las coordenadas de las \glspl{bbox} corporales.

%, que otorga el grado de similitud entre dos vectores \cite{andrew}

\subsection{Arquitectura extendida}
\label{sec:finalsys}

\afterpage{
    \begin{landscape}
        \begin{figure}[tbp]
            \centering
            \includegraphics[width=1.1\linewidth]{imagenes/FINALSYS.jpg}
            \caption{Arquitectura del sistema extendido, los módulos en negrita se corresponden con los nuevos componentes desarrollados.}
            \label{fig:finalsys}
        \end{figure}
    \end{landscape}
}

En la figura \ref{fig:finalsys} se muestra la arquitectura extendida, los nuevos componentes desarrollados se encuentran marcados en negrita. %, mientras que el resto de la arquitectura sigue la estructura ya comentada. 
Debido a que el nodo \acrshort{lidar} no está dentro del foco de este proyecto y tampoco se pudo realizar una migración satisfactoria a \acrshort{ros} 2 del mismo (ver sección \ref{subsec:ROS2}), se ha decidido \textbf{omitirlo} del nuevo sistema extendido. En concreto, se han propuesto los siguientes componentes:

\begin{description}
    \item[Procesamiento de vídeo] Implementa el procesamiento de \textbf{secuencias de frames} (o vídeos, en sustitución del esquema frame a frame), con el fin de explotar la coherencia espacio-temporal. Dicho módulo agrupa las \glspl{bbox} por individuos en más de un frame, que posteriormente se transforman en \glspl{embedding} y se guardan en una lista, que sirve de entrada para el módulo de \textbf{reconocimiento adaptativo}.
    \item[Reconocimiento adaptativo] Implementa la capacidad de detección e inclusión de desconocidos en el sistema (modo \textbf{\textit{Open-Set} y \textit{Open-World}}), en sustitución del reconocimiento mediante la \textbf{distancia coseno}. Evalúa%, mediante el uso de la teoría estadística (\acrshort{evt} introducido en la sección \ref{sec:incrlearning}), 
        (mediante el \acrshort{evt} introducido en la sección \ref{sec:incrlearning}) si la \textbf{mejor puntuación} obtenida de un individuo es un caso \textbf{extremo} respecto al resto de puntos (personas) de la distribución. En caso afirmativo, se trata de un conocido, en caso contrario, de un desconocido. En ambos casos, el sistema actualiza su conocimiento acerca del individuo por medio de la base de datos de \textbf{personas registradas}.
    \item[Personas registradas] representa al conocimiento existente acerca de los individuos, que es compartido por \textbf{todo el sistema}, es decir, por todos los nodos cámara. Este módulo también abarca la inicialización de dicho registro al arrancar el sistema y los distintos métodos para su compartición entre nodos.
\end{description}

Las \textbf{puntuaciones} utilizadas por el reconocimiento adaptativo no son más que los \textbf{resultados de los comités de \acrshort{svm}} sobre las secuencias de \glspl{embedding} de cada individuo (en la sección \ref{sec:val} se indaga en este asunto). En la sección \ref{sec:clasf} se ha justificado la elección de los comités de \acrshort{svm} frente a otros clasificadores por su capacidad de generalización y poder discriminativo.

%A continuación, se exponen en detalle los componentes recién comentados.

\section{Procesamiento de vídeo}
\label{sec:vídeo}
El sistema de partida trabaja a nivel de frame \cite{andrew}, es decir, devuelve predicciones de los individuos presentes en una sola imagen. Esta aproximación permite trabajar a altas frecuencias (ejemplo: devolver un reconocimiento cada 100 ms), sin embargo, las predicciones dependen enteramente de la calidad del frame (ejemplo: nivel de borrosidad). En este proyecto se ha optado por trabajar con \textbf{secuencias de frames} (o vídeos), de esta forma, se devuelve un reconocimiento más robusto basado en múltiples frames.

En cada frame, se extraen las \glspl{bbox} de los individuos presentes a partir de los modelos de detección de caras y cuerpos, que posteriormente se asocian entre el \textbf{frame actual y el anterior}, hasta establecer una secuencia completa. El resultado final es una lista (lista de entidades en la figura \ref{fig:finalsys}), que contiene listas de \glspl{bbox} transformadas en \glspl{embedding} (aplicando los modelos de reconocimiento) para cada individuo. El tamaño de la secuencia es ajustable según las necesidades del operador (ejemplo: secuencia de 10 frames, que equivale a 1 segundo si las cámaras funcionan a 10 Hz).

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{imagenes/Seq.jpg}
    \caption{Nuestra aplicación del método húngaro para el seguimiento de personas.}
    \label{fig:seq}
\end{figure}

En casos como los del \gls{dataset} FACE COX \cite{cox}, donde en los vídeos siempre aparece una sola persona, la agrupación de las entidades es trivial. Sin embargo, en un vídeo donde aparecen múltiples individuos que se entrecruzan, es necesario adoptar un método para \textbf{seguir el rastro de cada persona entre frames}. Se ha aplicado el \textbf{método húngaro} (introducido en la sección \ref{sec:trackerwork}) para relacionar las \glspl{bbox} según su \textbf{grado de solape} en dos frames adyacentes, en este caso, el \textbf{frame actual y el anterior}. Se genera la matriz de costes, donde las \glspl{bbox} (o recortes) del frame anterior se encuentran en las filas y las \glspl{bbox} del frame actual en las columnas y se devuelven los pares de \textbf{menor coste}. Tras repetir el proceso en toda la secuencia, se obtiene la lista de recortes de cada persona según el rastro generado por el algoritmo. La figura \ref{fig:seq} muestra un ejemplo de funcionamiento del proceso comentado.

Los costes de cada par de la matriz se obtienen mediante el \textbf{\acrfull{iou}}, que devuelve el porcentaje de solapamiento y similitud entre \glspl{bbox} (como se muestra en la figura \ref{fig:iou}), de forma que recortes de diferente tamaño den un valor bajo aunque el solape sea alto (ejemplo: personas que coinciden en la imagen en diferentes profundidades). El resultado devuelto por el \acrshort{iou} \textbf{se invierte} (1-\acrshort{iou}), de forma que se asocia el \textbf{menor coste} a las \glspl{bbox} con \textbf{mayor solape y similitud}. Dadas dos \glspl{bbox} A y B, el \acrshort{iou} se calcula como sigue en la ecuación \ref{eq:iou}.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{imagenes/iou.jpg}
    \caption[Ejemplo de \emph{Intersection over Union}]{Ejemplo de \emph{Intersection over Union}, figura extraída de \cite{iou}}
    \label{fig:iou}
\end{figure}

\begin{equation}
    IoU = \frac{A \cap B}{A \cup B}\label{eq:iou}
\end{equation}

%Problema, si ocurre que 2 bboxes de un individuo no se solapan, y si se solapa otra bbox, por mínimo solape que sea (ejemplo:0.99) ya se realiza la asignación incorrecta.

Es posible que durante la detección, las \glspl{bbox} de una misma persona en frames consecutivos no se solapen debido a la velocidad de movimiento de la propia persona o a un movimiento de la cámara, lo que causa una \textbf{incorrecta} aplicación del método húngaro. En este caso, se asigna el \textbf{mayor coste} (valor de 1) a la relación (es decir, un valor de \acrshort{iou} de 0), lo que genera el riesgo de asociar \textbf{2 \glspl{bbox} de individuos diferentes}. Otro problema es el \textbf{no seguimiento} de la persona cuando se encuentra totalmente \textbf{ocluida}  y reaparece (ejemplo: se cruza un individuo justo delante) o si la persona gira su cabeza y su cara queda momentáneamente fuera de la visión de la cámara.

\begin{equation}
    \Delta r_{euclid} = \sqrt{\Delta x^{2} + \Delta y^{2}} \label{eq:eucl}
\end{equation}

En estos casos, se crearía una nueva entidad para el mismo individuo, lo que no es un comportamiento deseable. Por este motivo, es necesario aplicar un método que pueda \textbf{reidentificar a las personas} cuyo rastro se haya perdido temporalmente. Como ya se comentó en la sección \ref{sec:trackerwork}, el \textbf{filtro de Kalman} como método de reidentificación \textbf{no es beneficioso} para la aplicación de este proyecto, por lo que se ha optado por un método más sencillo basado en la \textbf{distancia euclidiana}. Siendo $\Delta x$ y $\Delta y$ la diferencia entre las coordenadas \acrshort{2d} de los \textbf{centros} de dos \glspl{bbox}, la distancia euclidiana se calcula como se muestra en la ecuación \ref{eq:eucl}.

\begin{figure}[tbp]
    \centering
    \includegraphics[width=1\linewidth]{imagenes/FOLREID.jpg}
    \caption{Diagrama de flujo del procesamiento de vídeo}
    \label{fig:reident}
\end{figure}

La figura \ref{fig:reident} muestra el diagrama de flujo del procesamiento de vídeo. Se itera la lista de entidades detectadas en la secuencia, que se contrasta con la lista de asignaciones del método húngaro entre dos frames. A partir de este punto, el flujo se divide en dos grandes ramas:

\begin{itemize}
    \item \textbf{La entidad posee asignación.} En este caso, si dicha asignación \textbf{no obtiene} el mayor coste, \textbf{se valida la asociación}, en caso contrario (las \glspl{bbox} del individuo no se solapan), se calcula la distancia entre el \textbf{centro} de las \glspl{bbox} con la asignación, si la distancia es \textbf{inferior a un valor de umbral} (las \glspl{bbox} son cercanas) \textbf{se valida la asociación}, en caso contrario, se ha \textbf{perdido el rastro del individuo}, por lo que se guardan las coordenadas de su \gls{bbox} para la \textbf{reidentificación}.
    \item \textbf{La entidad no posee asignación.} En este caso, se calcula la distancia entre las coordenadas guardadas y \textbf{cada \gls{bbox} sin asignación} en el frame actual, si se obtiene una distancia inferior al valor del umbral, \textbf{se asocian las \glspl{bbox}}, en caso contrario, se reanudará la reidentificación de la entidad en el \textbf{siguiente frame}.
\end{itemize}

El valor del umbral se fija de antemano \textbf{y se ajusta automáticamente en función de la resolución} de la cámara utilizando un escalado a partir de la \textbf{diagonal}. %(se calcula la diagonal de la resolución prefijada y la nueva resolución y se divide la diagonal de la resolución nueva entre la prefijada, el resultado se multiplica por el valor de umbral).

Finalmente, se añaden las nuevas entidades del frame actual (las que no han conseguido asignación por ninguno de los métodos) a la lista de entidades para ser tenidas en cuenta en futuros frames. A modo de regular el funcionamiento de la reidentificación, la localización de un individuo se abandona tras realizar un \textbf{máximo de intentos} controlado por una variable asignada a cada entidad (intentos\_loc en la figura \ref{fig:reident}). El valor de la variable se restablece si se reidentifica al individuo satisfactoriamente antes de alcanzar el límite.

\begin{figure}[tbp]
    \centering
    \begin{subfigure}[c]{0.18\textwidth}
        \includegraphics[width=\textwidth]{imagenes/eucl0.jpg}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[c]{0.18\textwidth}
        \includegraphics[width=\textwidth]{imagenes/eucl1.jpg}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[c]{0.18\textwidth}
        \includegraphics[width=\textwidth]{imagenes/eucl2.jpg}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[c]{0.18\textwidth}
        \includegraphics[width=\textwidth]{imagenes/eucl3.jpg}
    \end{subfigure}
    \caption{Reidentificación mediante la distancia euclidiana}
    \label{fig:eucls}
\end{figure}

En la figura \ref{fig:eucls} se expone un ejemplo real. En el primer frame, se muestran dos entidades etiquetadas con un identificador (0 y 1) y como se aplica la distancia euclidiana para la entidad 0, cuyas \glspl{bbox} no se solapan. En el segundo frame (figura \ref{fig:eucls}), la entidad 1 no encuentra ninguna asignación posible, debido a que va a ser ocluida, por lo tanto la posición de su última \gls{bbox} se guarda. En el tercer frame (figura \ref{fig:eucls}), la entidad 1 se encuentra totalmente ocluida por la entidad 0. Como en el instante posterior a dicho frame existe una \gls{bbox} sin ninguna asociación, se calcula la distancia euclidiana entre dicha \gls{bbox} respecto a la guardada de la entidad 1. Finalmente, la entidad 1 se reasigna en el último frame, debido a que la distancia calculada es inferior al umbral (figura \ref{fig:eucls}).

%Se aplica el método húngaro para asociar detecciones entre el frame anterior y el actual. Se itera la lista de entidades con los individuos detectados hasta el momento, si algún individuo posee la asignación de mayor coste o no se ha establecido, se aplica el método de reidentificación durante un máximo de frames, controlado por la variable intentos\_loc. Por cada intento fallido de localización, se decrementa dicha variable, así hasta llegar al 0, que es el punto en el que se descarta la localización. En el resto de casos, la asignación del frame anterior con el actual se realiza y se restablece de nuevo la variable de intentos (en el caso de reidentificación).

%Al final de cada iteración del módulo, se añaden las nuevas detecciones a la lista de entidades. Los nuevos casos se corresponden con asignaciones de \gls{bbox} que no se corresponden con ninguna entidad antes registrada.

\section{Reconocimiento adaptativo}
\label{sec:archrecon}

\begin{figure}[tbp]
    \centering
    \includegraphics[width=1\linewidth]{imagenes/ADAPTSYS.jpg}
    \caption{Diseño del módulo de reconocimiento adaptativo}
    \label{fig:ADAPTSYS}
\end{figure}

La figura \ref{fig:ADAPTSYS} muestra los componentes del módulo de reconocimiento adaptativo:
\begin{description}
    \item[Módulo de valoración] Devuelve las \textbf{puntuaciones mínimas} de cada comité a la secuencia de \glspl{embedding} de entrada.
    \item[Módulo de reconocimiento] Toma la decisión de reconocimiento basándose en la distribución de puntuaciones mínimas de todos los comités.
    \item[Módulo de actualización] Se encarga de crear un nuevo comité si se detecta un usuario nuevo (\textit{unknown}) o de crear una nueva \acrshort{svm} para registrar los cambios de un usuario ya registrado en el sistema (\textit{drift}).
    \item[Módulo de limitación] Reemplaza la \acrshort{svm} que menos aporta a un comité, en el caso de que se haya excedido el límite de \acrshort{svm}s en un comité.
\end{description}

La figura \ref{fig:ADAPTSYS} muestra el diseño del reconocimiento adaptativo. La secuencia de vectores del individuo son procesados por el \textbf{módulo de valoración} (módulo EDF en la figura \ref{fig:ADAPTSYS}), que devuelve las \textbf{puntuaciones mínimas} de cada comité ordenadas de menor a mayor. Así la primera puntuación (la mejor) se corresponde \textit{a priori} con el comité del individuo, mientras que el resto de puntuaciones conforman la distribución de mínimos. A partir de las puntuaciones el \textbf{módulo de reconocimiento} (módulo RDF en la figura \ref{fig:ADAPTSYS}) determina, mediante el \acrfull{evt}, si el comité corresponde realmente a un individuo (conocido) o no (desconocido). El \textbf{módulo de actualización} registra los cambios según la decisión de reconocimiento del individuo:

\begin{itemize}
    \item \textbf{El individuo es un conocido.} Se agrega al comité una nueva \acrshort{svm} entrenada con la secuencia de \glspl{embedding} del individuo como positivos y una selección aleatoria de las muestras de todos los individuos registrados \textbf{excepto el propio sujeto} como negativos.
    \item \textbf{El individuo es un desconocido.} Se crea un \textbf{nuevo comité} con una \acrshort{svm} entrenada con la secuencia de \glspl{embedding} del individuo como positivos y una selección aleatoria de las muestras de \textbf{todos los individuos registrados} como negativos.
\end{itemize}

Si el comité excede en el límite fijado de \acrshort{svm}s, el \textbf{módulo de limitación} determina la \acrshort{svm} que menos aporta a dicho comité y se \textbf{elimina}. %Sendos módulos de actualización y limitación se encargan de añadir, actualizar y eliminar las \acrshort{svm}, los comités y las muestras de los individuos a la base de datos de \textbf{personas registradas}.

Para facilitar la lectura de la memoria y, puesto que no se incluyen mejoras respecto a los diseños propuestos en \cite{Erik,CESAR}, los detalles de este módulo se han movido al apéndice \ref{chap:adaptrecon}.

\section{Personas registradas}
\label{sec:initarch}

El sistema crea y mantiene una base de datos con todas las personas registradas, que es compartida por \textbf{todos el sistema} y está formada por los comités, sus \acrshort{svm} y las muestras de cada individuo. Esta base de datos es actualizada por los módulos de actualización y limitación del reconocimiento adaptativo. A continuación se explican los diferentes procesos de \textbf{inicialización} propuestos, así como diferentes técnicas para compartir la información entre los nodos del sistema.

\subsection{Inicialización}
\label{sec:initieing}

%fundamental, debido a que la \acrshort{svm} inicial es la que define la identidad del comité. Si dicha \acrshort{svm} está compuesta por muestras de baja calidad (ejemplo: caras borrosas o parcialmente ocluidas), entonces el comité \textbf{no se identificará correctamente consigo mismo} y, por lo tanto, generará \textbf{mayor confusión} a la hora de aplicar Weibull, es decir, \textbf{se generarán más desconocidos}.

En esta primera fase del sistema se crean los registros de los individuos iniciales. Como se muestra en \cite{5samples}, el proceso de inicialización es \textbf{crítico} y depende de la calidad de las muestras escogidas. Se han propuesto las siguientes 2 aproximaciones acordes a los tipos de aprendizaje incremental vistos en la sección \ref{sec:incrtypes}.

\begin{description}
    \item[Semisupervisada] El operador realiza una selección de las muestras más representativas de cada individuo, de los que se obtienen las características (\glspl{embedding}) a partir de los modelos de reconocimiento. Una vez inicializada la base de datos, el sistema deja de recibir datos etiquetados para entrenarse con datos no etiquetados durante su operación.
    \item[No supervisada] El sistema se encarga de recoger las muestras en el instante en el que aparece un mínimo de entidades simultáneas en escena. A partir de los frames de las cámaras, que estarán sincronizadas, se obtienen las \glspl{bbox} por medio de los modelos de detección y se agrupan por individuo mediante el módulo de procesamiento de vídeo. Este método \textbf{no requiere de ninguna intervención por parte del operador}.
\end{description}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{imagenes/Init.jpg}
    \caption{Inicialización no supervisada del sistema}
    \label{fig:init}
\end{figure}


En la figura \ref{fig:init} se muestra el procedimiento de la inicialización no supervisada. Dado un número de cámaras \textbf{sincronizadas}, se busca un instante (o frame) en el que mínimo se detecten \textbf{5 personas} (equivalente al mínimo de puntos de la distribución para que el \acrshort{evt} sea efectivo \cite{Erik}) de forma simultánea entre todas las cámaras. En dicho instante, se aplica el método de procesamiento de vídeo para organizar las \glspl{bbox} por individuo, si no se obtienen suficientes \glspl{bbox} del sujeto, el sistema \textbf{repite el proceso de búsqueda} en otro instante. En caso contrario, se obtienen los \glspl{embedding} y se almacenan para la creación de las \acrshort{svm}. Con el fin de evitar las muestras de \textbf{mala calidad}, las \glspl{bbox} se \textbf{filtran} y se descartan si no cumplen con las siguientes condiciones:
\begin{itemize}
    \item La cara se encuentra enteramente dentro del plano
    \item La \gls{bbox} es más alta que ancha.
\end{itemize}

%Tras obtener los \glspl{embedding} por medio de uno de los 2 modos de inicialización, se crean los comités de cada usuario con una \textbf{\acrshort{svm} inicial}, que se entrena a partir de las propias muestras del individuo (conjunto de positivos) y una selección de muestras del resto de individuos (conjunto de negativos). Finalmente, los comités se añaden a la base de datos de \textbf{personas registradas}.

\subsection{Registro compartido}
\label{sec:shared}

En el sistema de partida (sección \ref{sec:partarch}), el registro inicial de individuos \textbf{no se modifica} (modo \textit{Closed-Set}), por lo tanto, no existe la necesidad de mantener una fuente centralizada de los datos y, en su lugar, cada nodo inicializa su propia copia. Para implementar el modo \textit{Open-Set} y \textit{Open-World}, es necesario \textbf{propagar los cambios} del módulo de reconocimiento adaptativo a \textbf{todos los nodos} del sistema. Debido a que el sistema es distribuido (computación en múltiples nodos) y los nodos están implementados en Python, es necesario explorar otras vías diferentes a la memoria compartida entre procesos. Se han propuesto las siguientes 2 alternativas:

\begin{description}
    \item[Base de datos centralizada] Todos los nodos acceden a una base de datos de baja latencia (ejemplo: base de datos puramente en memoria), de la que reciben el registro de personas actualizado. Dicha base de datos se encontraría en la misma máquina que el nodo integración de sensores, que realizaría las peticiones de escritura. Tras una petición de escritura, la base de datos propaga las modificaciones a todos los nodos conectados.
    \item[Red \acrshort{ros}] El nodo integración de sensores recibe los mensajes de los nodos cámara, de los que extraerá los nuevos cambios a la base de datos. Aprovechando la red creada por \acrshort{ros}, el nodo integrador difunde un mensaje con las nuevas modificaciones a un tópico en el que todos los nodos cámara estarán suscritos, de forma que puedan recibir y aplicar los cambios, manteniendo así su propia copia actualizada.
\end{description}

En ambos casos, el nodo integrador realiza un volcado periódico de la base de datos en un fichero a modo de preservar los cambios.

\input{contenido/tables/redvsros.tex}

En la tabla \ref{tab:redvsros} se muestran las ventajas y desventajas de los 2 métodos. La base de datos centralizada (ejemplo: Redis \cite{redis}) es la solución adecuada para implementar un sistema escalable, sin embargo, la latencia añadida en las lecturas/escrituras y el elevado uso de la memoria la hacen \textbf{inabarcable} para sistemas embebidos de pocos recursos (ejemplo: Jetson Orin Nano). Por el otro lado, la red \acrshort{ros} suprime las latencias de lectura y escritura y se comporta adecuadamente con un número moderado de individuos, por lo que para este proyecto se vuelve \textbf{más conveniente}, sobretodo para dispositivos como la Jetson Orin Nano.